{{#> layout title="The Grammar Definition Part"}}
<h1>The Grammar Definition Part</h1>
<p>The second &mdash; and most important &mdash; part of a JS/CC parser definition is the grammar definition
    part. In this part, below the <code>##</code> symbol, the definition of the context-free grammar to be parsed
    by the generated parser is described. This is done by using a Backus-Naur-Form variant meta-language, by defining
    non-terminals and their productions.</p>
<p>The general syntax for a non-terminal and its productions is:</p>
<pre>
    non-terminal : production<sup>1</sup> semantic-code
                 | production<sup>2</sup> semantic-code
                        &vellip;
                 | production<sup>n</sup> semantic-code
</pre>
<p>The <i>non-terminal</i> defines a single-word identifier and acts as the left-hand side for the related productions
    attached to this symbol.</p>
<p>The <i>production</i> defines a sequence of zero or multiple terminals and non-terminals, defining the different
    syntax rules. To specify terminal symbols, it is possible to call them via their (unescaped) regular expression via
    a string-value or by their label, which need not (but can) be specified as a string value. In the
    <a href="{{resolve "documentation/quickstart/example.html"}}">example</a>, both methods are used:
    <code>FLOAT</code> is called by its label, while the token <code>'+'</code> is called by the name generated
    from its regular expression.</p>
<p>The semantic-code part behind the productions is optional. It defines an individual semantic code which is
    executed right before the according production is reduced to its left-hand side. Same as in the token definition
    part, semantic code is enclosed by <code>[*</code> and <code>*]</code> and will be concatenated to one code
    segment which is associated with the according productions when multiple semantic code segments are specified in
    a row. Read more about this in the section below.</p>
<p>Note that in the above syntax scheme the number of productions is completely variable. At least, one right-hand
    side must be given to an according left-hand side, although this can be an epsilon production.</p>
<p>Each production is separated by a vertical "pipe" bar (<code>|</code>) from the others, and a non-terminal
    definition must always be closed by a semicolon. Else, JS/CC cannot distinguish whether the next symbol belongs
    to the right-hand side it currently parses or whether it reads a new non-terminal definition.</p>
<p>Non-terminal symbols can be called on a right-hand side before they are defined, so the order in which the rules are
    defined is arbitrary. Integrative checks on the grammar are done by JS/CC before the parse tables are
    constructed.</p>
<h2>Accessing right-hand side items in semantic action</h2>
<p>Within each semantic action attached to a production, as described above, the values of the right-hand side symbols
    can be accessed via wild cards, which are replaced by the particular variables and offsets later in the resulting
    parser.</p>
<p>The <code>%n</code> wild cards are used to address every individual token starting from the left of the right-hand
    side.</p>
<p>The <code>%%</code> wild card relates to the value of the left-hand side which is pushed to the parser's value stack
    right after the right-hand side symbols are popped.</p>
<p>So by passing a value to the <code>%%</code> wild card causes the inheritance of values from the current right-hand
    side to another call of the according non-terminal on a right-hand side within the parse tree. The values on the
    current right-hand side will be discarded when the reduction process occurs, and the value attached to
    <code>%%</code> is pushed instead, so it can be used elsewhere.</p>
<p>As example, in the given production:</p>
{{#code "jscc"}}
    expr:               expr '+' term                   [* %% = %1 + %3; *]
{{/code}}
<p>of the <a href="{{resolve "documentation/quickstart/example.html"}}">expression calculator</a>, the return values
    of the <code>expr</code> and the <code>term</code> on the right-hand side, which are addressed via
    <code>%1</code> and <code>%3</code> (<code>%2</code> addresses the value of the <code>'+'</code>
    terminal) are added together, and the result is stored to the left-hand side (the <code>expr</code> on the far
    left in this case). Thus, you have full control over all individual tokens within each production.</p>
<p>If no individual semantic action is given to a right-hand side, the default action</p>
{{#code "jscc"}}
    [* %% = %1; *]
{{/code}}
<p>is used.</p>
<p>Semantic action between the symbols of a right-hand side is not allowed, only behind them.</p>
<h2>Value types</h2>
<p>Because JS/CC was designed for use with JavaScript, or any other typeless scripting language, it is not necessary
    to define &mdash; as in yacc &mdash; a special union structure to hold the values on the value stack. Both
    built-in primary types like <code>String</code> or <code>Number</code> objects as well as user-defined objects
    (each function in JavaScript is internally represented by an object) can be pushed to and popped off the value
    stack.</p>
<p>So don't confuse the values; you have to know which value stands on which position.</p>
<h2>Resolving conflicts</h2>
<p>To automatically resolve shift-reduce or reduce-reduce conflicts at parse table generation, JS/CC features, by
    default, two mechanisms.</p>
<p>When a shift-reduce conflict occurs, JS/CC constructs the parse tables in favor of the shift, so the parse
    tree will grow right-derivative.</p>
<p>When a reduce-reduce conflict occurs, JS/CC resolves the problem by reducing the production which was defined
    first, so productions which were defined earlier in the grammar will be reduced in favor when this conflict
    arises.</p>
<p>As described in <a href="{{resolve "documentation/grammar/terminal.html"}}">The Terminal Declaration Part</a>,
    JS/CC features the possibility of manipulating the natural parse table generated by the LALR(1) table construction
    algorithm by weighting terminal symbols with a precedence level and an associativity. This information is used
    within shift-reduce conflicts to better decide if a shift or a reduce operation should be inserted. If a
    shift-reduce conflict arises, the precedence level and associativity information is compared with the according
    production's precedence level because every production will, by default, get the same precedence level as its
    rightmost terminal symbol.</p>
<p>To explain this behavior, let's look at the following example. It defines a calculator like the first example,
    but with less effort in writing the grammar. Here, we have only two non-terminal symbols instead of four, but
    we implement the same operator precedence behavior as in the original one.</p>
{{#code "jscc"}}
    /~ Tokens to be ignored (e.g., whitespace, comments) ~/
    !      ' |\t';

    /~ Left-associative tokens, lowest precedence ~/
    <     '\+'
          '\-';

    /~ Left-associative tokens, highest precedence ~/
    <     '\*'
          '/';

    /~ Tokens with no associativity ~/
    '\('
    '\)'
    '[0-9]+'                          INT      [* %match = parseInt( %match );    *]
    '[0-9]+\.[0-9]*|[0-9]*\.[0-9]+'   FLOAT    [* %match = parseFloat ( %match ); *]
    ;

    ##

    program:   expr            [* print( %1 );   *]
           ;

    expr:      expr '+' expr   [* %% = %1 + %3;  *]
               | expr '-' expr [* %% = %1 - %3; *]
               | expr '*' expr [* %% = %1 / %3; *]
               | expr '/' expr [* %% = %1 / %3; *]
               | '(' expr ')'  [* %% = %2; *]
               | INT
               | FLOAT
               ;
{{/code}}
<p>Sometimes, it will also be necessary to give a production another precedence level than the one of the
    rightmost terminal. For example, if we want to add a unary-minus operator to the grammar above, the
    production adopts the precedence level of the minus-symbol by default. But this minus-operator was
    configured for its use in a binary subtraction, not in a unary subtraction. By simply adding a new
    rule for unary minus to the grammar, most simple expressions will return the right result
    (e.g., <code>-2+3</code>), but in expressions like <code>4/-4*5</code>, the result will simply be wrong because,
    through our precedence rules for multiplication, the generated parser parses <code>4/(-(4*5))</code>
    instead of <code>(4/(-4))*5</code>.</p>
<p>To resolve this problem, we need to attach a higher precedence level to the production for unary
    minus. For this special case, JS/CC features the <code>&amp;</code>-directive.
    The <code>&amp;</code>-directive must be specified behind the rule's definition and in front of
    the semantic code action (if any). Behind the <code>&amp;</code>-directive, a terminal symbol
    (both as string or its label) is specified, which precedence level is taken by the production
    instead of its default value.</p>
<p>So by changing the grammar to:</p>
{{#code "jscc"}}
    expr:      expr '+' expr   [* %% = %1 + %3;  *]
               | expr '-' expr [* %% = %1 - %3; *]
               | expr '*' expr [* %% = %1 / %3; *]
               | expr '/' expr [* %% = %1 / %3; *]
               | '(' expr ')'  [* %% = %2; *]
               | '-' expr      &'*'  [* %% = %2 * -1; *]
               | INT
               | FLOAT
               ;
{{/code}}
<p>we get the right parse tree and result, because our rule with the unary minus has a higher precedence now
    and reduces instead of shifting in the desired cases.</p>
{{/layout}}