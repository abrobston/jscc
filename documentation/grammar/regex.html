<!doctype html>
<html>
<!-- This file is automatically generated.  Please edit the templates (e.g., pages/*.hbs, partial/*.hbs) instead
     of editing the .html file directly. -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>JS/CC &mdash; Regular Expressions</title>
    <link id="main-stylesheet" rel="stylesheet" href="../../stylesheets/main-light.css"/>
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed navbar-toggle collapsed" type="button" data-toggle="collapse"
              data-target="#navbar-collapse-1" aria-expanded="false"><span
        class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span
        class="icon-bar"></span></button>
      <a href="../../index.html" class="navbar-brand">JS/CC</a>
    </div>
    <div class="collapse navbar-collapse" id="navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="../../getting-started.html">Getting Started</a></li>
        <li><a href="../introducing/welcome.html">Documentation</a></li>
        <li><a href="../../demo.html">Demo</a></li>
        <li><a href="../../licenses.html">Licenses</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="#" id="toggle-theme">Toggle Theme</a></li>
        <li><a href="../../contact.html">Contact</a></li>
        <li><a href="https://github.com/abrobston/jscc">GitHub</a></li>
      </ul>
    </div>
  </div>
</nav>
    <div class="container-fluid">
        <div class="row">
            <div class="documentation-table-of-contents">
              <ul class="nav nav-pills nav-stacked">
                    <li class="dropdown" role="presentation">
                        <a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Introducing JS/CC <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                              <li><a href="../introducing/welcome.html">Welcome to JS/CC</a></li>
                              <li><a href="../introducing/intention.html">The intention behind JS/CC</a></li>
                              <li><a href="../introducing/future.html">Future plans</a></li>
                              <li><a href="../introducing/words.html">Some words by the author</a></li>
                        </ul>
                    </li>
                    <li class="dropdown" role="presentation">
                        <a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">A Quick Start Example <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                              <li><a href="../quickstart/building.html">Building JS/CC for your platform</a></li>
                              <li><a href="../quickstart/installation.html">Installation and Start-Up</a></li>
                              <li><a href="../quickstart/options.html">Compiler options</a></li>
                              <li><a href="../quickstart/example.html">An example parser</a></li>
                              <li><a href="../quickstart/compiling.html">Compiling the example</a></li>
                        </ul>
                    </li>
                    <li class="dropdown" role="presentation">
                        <a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">The Grammar Definition Language <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                              <li><a href="general.html">General</a></li>
                              <li><a href="terminal.html">The Terminal Declaration Part</a></li>
                              <li><a href="regex.html">Regular Expressions</a></li>
                              <li><a href="grammar.html">The Grammar Definition Part</a></li>
                        </ul>
                    </li>
                    <li class="dropdown" role="presentation">
                        <a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Implementing a Scripting Language <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                              <li><a href="../implementing/idea.html">The idea</a></li>
                              <li><a href="../implementing/defining.html">Defining the grammar</a></li>
                              <li><a href="../implementing/executing.html">Executing the script</a></li>
                              <li><a href="../implementing/complete.html">The complete program</a></li>
                        </ul>
                    </li>
              </ul>            </div>
            <div class="documentation-main">
              <div class="row">
                  <nav>
                        <ul class="pager">
                              <li class="previous"><a href="terminal.html"><span
                                      aria-hidden="true">&larr;</span> The Terminal Declaration Part</a></li>
                              <li class="next"><a href="grammar.html">The Grammar Definition Part <span aria-hidden="true">&rarr;</span></a>
                              </li>
                        </ul>
                  </nav>
              </div>              <h1>Regular Expressions</h1>
              <p>Because it was impossible to build a properly-working lexical analyzer using JavaScript's built-in RegExp object,
                  JS/CC features its own implementation of regular-expression processing. This is also the reason that not all the
                  features of the JavaScript RegExp object are provided, like back-references and predefined character classes.</p>
              <p>The symbols and operators to be used within JS/CC's own regular-expression language are summarized in the following
                  table. They form a minimal implementation of a regular-expression engine.</p>
              <table class="table table-border">
                  <thead>
                  <tr>
                      <th>Language Element</th>
                      <th>Description</th>
                  </tr>
                  </thead>
                  <tbody>
                  <tr>
                      <td>Character</td>
                      <td>One character specifies exactly that character. If a regular-expression operator like
                          <code>+</code> or <code>*</code> should be used, it must be escaped via <code>\</code>.
                      </td>
                  </tr>
                  <tr>
                      <td><code>\ascii-code</code></td>
                      <td>One character, defined via ASCII-code., e.g., <code>"\220"</code> matches the
                          &Uuml;-umlaut of the extended ASCII table.
                      </td>
                  </tr>
                  <tr>
                      <td><code>\character</code></td>
                      <td>Escaped character. Must be used when a character of the meta-language itself should be
                          matched, e.g., <code>"\|"</code>.
                      </td>
                  </tr>
                  <tr>
                      <td><code>.</code></td>
                      <td>Any character (character class matching all available characters).</td>
                  </tr>
                  <tr>
                      <td><code>[&hellip;]</code></td>
                      <td>Character-class. If a beginning circumflex (<code>^</code>) is given,
                          the character-class is negated. Character ranges can be specified using a
                          dash. For example, <code>"[A-Za-z]"</code> specifies all capital and
                          lower-case alphabet letters.
                      </td>
                  </tr>
                  <tr>
                      <td><code>(&hellip;)</code></td>
                      <td>Sub-expression.</td>
                  </tr>
                  <tr>
                      <td><code>|</code></td>
                      <td>Or-operator. Allows to specify different expressions at one level.</td>
                  </tr>
                  <tr>
                      <td><code>*</code></td>
                      <td>Kleene-closure operator (none or many), to be specified behind a character,
                          character-class, or sub-expression.
                      </td>
                  </tr>
                  <tr>
                      <td><code>+</code></td>
                      <td>Positive-closure operator (one or many), to be specified behind a character,
                          character-class, or sub-expression.
                      </td>
                  </tr>
                  <tr>
                      <td><code>?</code></td>
                      <td>Optional-closure operator (one or none), to be specified behind a character,
                          character-class, or sub-expression.
                      </td>
                  </tr>
                  </tbody>
              </table>
              <p>To allow case-insensitive keywords within grammar definitions, a terminal symbol definition can be
                  specified using single-quoted (<code>'&hellip;'</code>) and double-quoted (<code>"&hellip;"</code>)
                  strings. A single-quoted string means that a terminal symbol is matched case-sensitive, while a
                  double-quoted string matches a terminal in any case order. For example, the terminal symbol
                  definition <code>"PRINT"</code> will match for <i>Print</i>, <i>print</i>, <i>PrINT</i>, and
                  <i>PRINT</i>, while the definition <code>'PRINT'</code> will only match for <i>PRINT</i> itself.</p>
              <p>From these regular expression definitions, JS/CC constructs a deterministic finite automaton which
                  acts as lexer in the resulting parser.</p>
              <h2>Ambiguous Regular Expressions</h2>
              <p>If there are ambiguous regular expressions (where several expressions match the same string) within the
                  terminal definition part, the expressions defined first in the terminal definition part will take higher
                  match precedence than the later-defined terminals. It is recommended to define tokens with a higher
                  specialization level as the first, and tokens with a lower level as the last in your token definition part.</p>
              <h2>Associativity and Precedence</h2>
              <p>Tokens can be grouped by precedence levels and associativity. This feature allows writing faster and even
                  smaller grammars, by resolving grammar conflicts by weighting terminal symbols.</p>
              <p>A group without a group specifier will set no associativity and a precedence level of zero to all terminal
                  symbols in this group (as in the first example).</p>
              <p>Else, if a group begins with the symbol <code>&lt;</code> for left-associativity, <code>&gt;</code> for
                  right-associativity, or <code>^</code> for non-associativity, all terminal symbols within this group are set to
                  the according associativity and precedence level. The precedence level is incremented each time a new group
                  of these three types is opened, so groups that are defined at the bottom of the token definition part take the
                  highest precedence.</p>
              <p>The precedence information as associativity is used to resolve conflicts in ambiguous grammars by modifying the
                  parse table's natural content. How this works in practice is described in
                  <a href="grammar.html">The Grammar Definition Part</a> in the section dealing
                  with grammar conflicts and their handling.</p>
              <h2>Whitespace</h2>
              <p>A special type of terminal symbol is introduced by the exclamation-mark (<code>!</code>) symbol: the whitespace
                  symbols!</p>
              <p>In this definition, there is only a regular expression possible. A label or code part is prohibited. As
                  whitespace-tokens, terminals that should always be ignored can be specified, e.g., blanks, tabs, or comments.</p>
              <div class="row">
                  <nav>
                        <ul class="pager">
                              <li class="previous"><a href="terminal.html"><span
                                      aria-hidden="true">&larr;</span> The Terminal Declaration Part</a></li>
                              <li class="next"><a href="grammar.html">The Grammar Definition Part <span aria-hidden="true">&rarr;</span></a>
                              </li>
                        </ul>
                  </nav>
              </div>            </div>
        </div>
        <div class="row">
            <div class="col-xs-12">
              <footer>
                  <p>The JS/CC project is maintained by <a href="https://github.com/abrobston">Andrew Brobston</a>. Documentation is
                      by Jan Max Meyer and edited by Andrew Brobston. Contributions to this website are welcome. Please see the <a
                              href="https://github.com/abrobston/jscc/blob/gh-pages/README.md">README</a> for further information.</p>
                  <p><a href="../../licenses.html">Licenses</a> | <a href="../../contact.html">Contact</a>
                  </p>
                  <p>Hosted on GitHub Pages</p>
              </footer>
            </div>
        </div>
    </div>
    <script src="../../javascripts/main-built.js"></script>
</body>
</html>
