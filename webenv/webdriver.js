var webdriver_t = "##HEADER##\n\n/*\n\tJS/CC LALR(1) Parser Generator\n\tCopyright (C) 2007-2012 by Phorward Software Technologies, Jan Max Meyer\n\thttp://jscc.phorward-software.com + contact<<AT>>phorward-software<<DOT>>com\n\n\tFile:\tjscc.html\n\tAuthor:\tJan Max Meyer\n\tUsage:\tModified parser template for the Web Environment Module\n\t\t\tBased on \"driver_web.js_\" parser template, but NOT\n\t\t\tin the public domain!\n\n\tYou may use, modify and distribute this software under the terms and\n\tconditions of the BSD license. Please see LICENSE for more information.\n\n\tDriver for the JS/CC Web Environment with integrated HTML\n\tparse tree generator!\n*/\n##HEADER##\n\nvar ##PREFIX##_dbg_withparsetree\t= true;\nvar ##PREFIX##_dbg_withtrace\t\t= false;\nvar ##PREFIX##_dbg_withstepbystep\t= false;\nvar ##PREFIX##_dbg_string\t\t\t= new String();\n\nfunction __##PREFIX##dbg_print( text )\n{\n\t##PREFIX##_dbg_string += text + \"\\n\";\n}\n\nfunction __##PREFIX##dbg_flush()\n{\n\talert( ##PREFIX##_dbg_string );\n}\n\nfunction __##PREFIX##dbg_wait()\n{\n\t//Not implemented for Web.\n}\n\nfunction __##PREFIX##dbg_parsetree( indent, nodes, tree )\n{\n\t//Not implemented for Web.\n}\n\nfunction __##PREFIX##dbg_image( name )\n{\n\treturn \"<img src=\\\"img/\" + name + \".png\\\" \" +\n\t\t\t\"style=\\\"border: 0px; margin: 0px; padding: 0px;\\\" />\";\n}\n\nfunction __##PREFIX##dbg_get_tree_depth( nodes, tree, max )\n{\n\tvar\t\ttmp\t\t= 0;\n\n\tfor( var i = 0; i < tree.length; i++ )\n\t{\n\t\tif( nodes[ tree[i] ].child.length > 0 )\n\t\t\tif( max < ( tmp = __dbg_get_tree_depth(\n\t\t\t\t\t\t\t\t\tnodes, nodes[ tree[i] ].child, max+1 ) ) )\n\t\t\t\tmax = tmp;\n\t}\n\n\treturn max;\n}\n\nfunction __##PREFIX##dbg_parsetree( cnt, nodes, tree, prev, depth )\n{\n\tvar str = new String();\n\n\tif( typeof( prev ) == \"undefined\" )\n\t{\n\t\tstr += \"<table border=\\\"0\\\" cellpadding=\\\"0\\\" \" +\n\t\t\t\t\t\"cellspacing=\\\"0\\\" class=\\\"parsetree\\\">\";\n\n\t\tdepth = __##PREFIX##dbg_get_tree_depth( nodes, tree, 0 )\n\t\tprev = new Array();\n\t}\n\n\tif( cnt > 0 )\n\t\tprev[cnt-1] = true;\n\n\tfor( var i = 0; i < tree.length; i++ )\n\t{\n\t\tstr += \"<tr>\";\n\n\t\tfor( var j = 0; j < cnt; j++ )\n\t\t{\n\t\t\tstr += \"<td>\";\n\n\t\t\tif( prev[j] )\n\t\t\t{\n\t\t\t\tif( j == cnt - 1 && i == tree.length - 1 )\n\t\t\t\t\tstr += __##PREFIX##dbg_image( \"ll\" );\n\t\t\t\telse if( j == cnt - 1 )\n\t\t\t\t\tstr += __##PREFIX##dbg_image( \"la\" );\n\t\t\t\telse\n\t\t\t\t\tstr += __##PREFIX##dbg_image( \"l\" );\n\t\t\t}\n\t\t\telse\n\t\t\t\tstr += __##PREFIX##dbg_image( \"e\" );\n\n\t\t\tstr += \"</td>\";\n\t\t}\n\n\t\tif( cnt > 0 && i == tree.length - 1 )\n\t\t\tprev[cnt-1] = false;\n\n\t\tstr += \"<td>\";\n\t\tif( nodes[ tree[i] ].child.length > 0 )\n\t\t\tif( cnt == 0 )\n\t\t\t\tstr += __##PREFIX##dbg_image( \"rn\" );\n\t\t\telse\n\t\t\t\tstr += __##PREFIX##dbg_image( \"n\" );\n\t\telse\n\t\t\tstr += __##PREFIX##dbg_image( \"t\" );\n\t\tstr += \"</td>\";\n\n\t\tstr += \"<td class=\\\"node_name\\\" colspan=\\\"\" + ( depth - cnt + 1 ) +\n\t\t\t\t\t \"\\\">\" + nodes[ tree[i] ].sym ;\n\t\tif( nodes[ tree[i] ].att && nodes[ tree[i] ].att != \"\" )\n\t\t\tstr += \":<span>\" + nodes[ tree[i] ].att + \"</span>\" ;\n\n\t\tstr += \"</td>\";\n\n\t\tif( nodes[ tree[i] ].child.length > 0 )\n\t\t\tstr += __##PREFIX##dbg_parsetree(\n\t\t\t\t\t\tcnt+1, nodes, nodes[ tree[i] ].child, prev, depth );\n\t}\n\n\tif( cnt == 0 )\n\t\tdocument.getElementById( \"parsetree\" ).innerHTML = str + \"</table>\";\n\n\treturn str;\n}\n\nfunction __##PREFIX##dbg_parsetree_phpSyntaxTree( nodes, tree )\n{\n\tvar str = new String();\n\n\tfor( var i = 0; i < tree.length; i++ )\n\t{\n\t\tstr += \" [ \";\n\n\t\tstr += nodes[ tree[i] ].sym;\n\t\tif( nodes[ tree[i] ].att && nodes[ tree[i] ].att != \"\" )\n\t\t{\n\t\t\tvar attr = new String( nodes[ tree[i] ].att );\n\t\t\tstr += \":\\\"\" + attr.replace( / |\\t|\\r|\\n|\\[|\\]/g, \"_\" ) + \"\\\"\";\n\t\t}\n\n\t\tstr += \" \";\n\n\t\tif( nodes[ tree[i] ].child.length > 0 )\n\t\t\tstr += __##PREFIX##dbg_parsetree_phpSyntaxTree(\n\t\t\t\t\t\t\tnodes, nodes[ tree[i] ].child );\n\n\t\tstr += \" ] \";\n\t}\n\n\treturn str;\n}\n\n\n\n/*\n\tThis is the general, platform-independent part of every parser driver;\n\tInput-/Output and Feature-Functions are done by the particular drivers\n\tcreated for the particular platform.\n*/\n##HEADER##\nvar __##PREFIX##parse=(function(debug,eof,whitespace,error_token){\n##DFA##\n\tfunction DFA(state,chr,match,pos,set_match,set_match_pos,set_state){\n\t\tvar line = DFA_DATA[state].line;\n\t\tvar p,st;\n\t\tfor(p=1<<8,st=line;p;p>>=1){\n\t\t\tst=st[!!(chr&p)+0];\n\t\t\tif(st==null)break;\n\t\t\tif(st instanceof Array)continue;\n\t\t\tbreak;\n\t\t}\n\t\tvar ac=DFA_DATA[state].accept;\n\t\tset_state(st)\n\t\tif(ac!=-1){\n\t\t\tset_match(ac);\n\t\t\tset_match_pos(pos);\n\t\t}\n\t}\n\tfunction TERMINAL_ACTIONS(PCB,match){\n##TERMINAL_ACTIONS##\n\t}\n\tfunction lex(PCB){\n\t\tvar state, match, match_pos, start, pos, chr;\n\t\t\n\t\t///Functions for manipulation of variables\n\t\tfunction set_match(v){match=v;}\n\t\tfunction set_state(v){state=v;}\n\t\tfunction set_match_pos(v){match_pos=v;}\n\t\t\n\t\twhile(true){\n\t\t\tmatch_pos = 0;\n\t\t\tpos = PCB.offset + 1;\n\t\t\tdo{\n\t\t\t\tpos--;\n\t\t\t\tstate = 0;\n\t\t\t\tmatch = null;\n\t\t\t\tstart = pos;\n\t\t\t\tif(PCB.src.length <= start)\n\t\t\t\t\treturn eof;\n\t\t\t\tdo{\n\t\t\t\t\tchr = PCB.src.charCodeAt(pos);\n\t\t\t\t\tDFA(state,chr,match,pos,set_match,set_match_pos,set_state);\n\t\t\t\t\tif(state != null){\n\t\t\t\t\t\tif( chr === 10 ){\n\t\t\t\t\t\t\tPCB.line++;\n\t\t\t\t\t\t\tPCB.column = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPCB.column++;\n\t\t\t\t\t}\n\t\t\t\t\tpos++;\n\t\t\t\t}while(state != null);\n\t\t\t}while(whitespace > -1 && match == whitespace);\n\t\t\tif(match != null){\n\t\t\t\tPCB.att = PCB.src.slice(start, match_pos);\n\t\t\t\tPCB.offset = match_pos;\n\t\t\t\tif((function(){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tTERMINAL_ACTIONS(PCB,match);\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tif(e===Continue)return true;\n\t\t\t\t\t\telse throw e;\n\t\t\t\t\t}\n\t\t\t\t})())continue;\n\t\t\t}else\n\t\t\t\tPCB.att = \"\";\n\t\t\treturn match;\n\t\t}\n\t}\n##TABLES##\n##LABELS##\n\tfunction ACTIONS(act,vstack){\n\t\tvar rval;\n##ACTIONS##\n\t\treturn rval;\n\t}\n\tfunction get_act(top, la){\t\n\t\tfor(var i = 0; i < act_tab[top].length; i+=2)\n\t\t\tif(act_tab[top][i] === la)\n\t\t\t\treturn act_tab[top][i+1];\n\t\treturn null;\n\t}\n\tfunction get_goto(top, pop){\t\n\t\tfor(var i = 0; i < goto_tab[top].length; i+=2)\n\t\t\tif(goto_tab[top][i] === pop)\n\t\t\t\treturn goto_tab[top][i+1];\n\t\treturn null;\n\t}\n\tfunction parse(src, err_off, err_la){\n\t\tvar\t\tsstack\t\t\t= [0];\n\t\tvar\t\tvstack\t\t\t= [0];\n\t\tvar \terr_cnt\t\t\t= 0;\n\t\tvar\t\trval;\n\t\tvar\t\tact;\n\t\tvar\t\ttreenodes\t\t= [];//DEBUG!!!\n\t\tvar\t\ttree\t\t\t= [];//DEBUG!!!\n\t\tvar\t\ttmptree\t\t\t= null;//DEBUG!!!\n\t\tvar i;\n\n\t\tvar PCB\t= {\n\t\t\tline:1,\n\t\t\tcolumn:1,\n\t\t\toffset:0,\n\t\t\terror_step:0,\n\t\t\tsrc:src,\n\t\t\tatt:\"\",\n\t\t\tlex:function(){return this.la = lex(this);}///@TODO: change `lex` function\n\t\t};\n\t\terr_off\t= err_off || [];\n\t\terr_la = err_la || [];\n\t\tPCB.lex();\n\t\twhile(true){\n\t\t\tPCB.act = get_act(sstack[0],PCB.la);\n\t\t\tif(PCB.act == null && defact_tab[sstack[0]] >= 0)\n\t\t\t\tPCB.act = -defact_tab[sstack[0]];\n\t\t\tif(debug._dbg_withtrace && sstack.length > 0){//DEBUG!!!\n\t\t\t\tdebug.__dbg_print( \"\\nState \" + sstack[0] + \"\\n\" +//DEBUG!!!\n\t\t\t\t\t\t\t\"\\tLookahead: \" + labels[PCB.la] +//DEBUG!!!\n\t\t\t\t\t\t\t\t\" (\\\"\" + PCB.att + \"\\\")\\n\" +//DEBUG!!!\n\t\t\t\t\t\t\t\"\\tAction: \" + PCB.act + \"\\n\" + //DEBUG!!!\n\t\t\t\t\t\t\t\"\\tSource: \\\"\" + PCB.src.substr( PCB.offset, 30 ) +//DEBUG!!!\n\t\t\t\t\t\t\t\t\t( ( PCB.offset + 30 < PCB.src.length ) ?//DEBUG!!!\n\t\t\t\t\t\t\t\t\t\t\"...\" : \"\" ) + \"\\\"\\n\" +//DEBUG!!!\n\t\t\t\t\t\t\t\"\\tStack: \" + sstack.join() + \"\\n\" +//DEBUG!!!\n\t\t\t\t\t\t\t\"\\tValue stack: \" + vstack.join() + \"\\n\" );//DEBUG!!!\n\t\t\t\tif(debug._dbg_withstepbystep)//DEBUG!!!\n\t\t\t\t\tdebug.__dbg_wait();//DEBUG!!!\n\t\t\t}//DEBUG!!!\n\t\t\tif(PCB.act == null){//Parse error? Try to recover!\n\t\t\t\tif( debug._dbg_withtrace ){//DEBUG!!!\n\t\t\t\t\tvar expect = \"\";//DEBUG!!!\n\t\t\t\t\tdebug.__dbg_print(\"Error detected: There is no reduce or shift on the symbol \" + labels[PCB.la]);//DEBUG!!!\n\t\t\t\t\tfor(i = 0; i < act_tab[sstack[0]].length; i+=2){//DEBUG!!!\n\t\t\t\t\t\tif( expect != \"\" )//DEBUG!!!\n\t\t\t\t\t\t\texpect += \", \";//DEBUG!!!\n\t\t\t\t\t\texpect += \"\\\"\" + labels[act_tab[sstack[0]][i]] + \"\\\"\";//DEBUG!!!\n\t\t\t\t\t}//DEBUG!!!\n\t\t\t\t\tdebug.__dbg_print( \"Expecting: \" + expect );//DEBUG!!!\n\t\t\t\t}//DEBUG!!!\n\t\t\t\t//Report errors only when error_step is 0, and this is not a\n\t\t\t\t//subsequent error from a previous parse\n\t\t\t\tif(PCB.error_step === 0){\n\t\t\t\t\terr_cnt++;\n\t\t\t\t\terr_off.unshift(PCB.offset - PCB.att.length);\n\t\t\t\t\terr_la.unshift([]);\n\t\t\t\t\tfor(i = 0; i < act_tab[sstack[0]].length; i+=2)\n\t\t\t\t\t\terr_la[0].push(labels[act_tab[sstack[0]][i]]);\n\t\t\t\t}\n\t\t\t\t//Perform error recovery\t\t\t\n\t\t\t\twhile(sstack.length > 1 && PCB.act == null){\n\t\t\t\t\tsstack.shift();\n\t\t\t\t\tvstack.shift();\n\t\t\t\t\t//Try to shift on error token\n\t\t\t\t\tPCB.act = get_act(sstack[0],PCB.la);\n\t\t\t\t\tif(PCB.act === error_token){\n\t\t\t\t\t\tsstack.unshift(PCB.act);\n\t\t\t\t\t\tvstack.unshift(\"\");\n\t\t\t\t\t\tif( debug._dbg_withtrace ){//DEBUG!!!\n\t\t\t\t\t\t\tdebug.__dbg_print(\"Error recovery: error token could be shifted!\" );//DEBUG!!!\n\t\t\t\t\t\t\tdebug.__dbg_print(\"Error recovery: current stack is \" + sstack.join());//DEBUG!!!\n\t\t\t\t\t\t}//DEBUG!!!\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//Is it better to leave the parser now?\n\t\t\t\tif(sstack.length > 1 && PCB.act != null){\n\t\t\t\t\t//Ok, now try to shift on the next tokens\n\t\t\t\t\twhile(PCB.la !== eof){\n\t\t\t\t\t\tif(debug._dbg_withtrace)//DEBUG!!!\n\t\t\t\t\t\t\tdebug.__dbg_print( \"Error recovery: Trying to shift on \\\"\"\t+ labels[ PCB.la ] + \"\\\"\" );//DEBUG!!!\n\t\t\t\t\t\tPCB.act = act_tab[sstack[0]][i+1];\n\t\t\t\t\t\tif(PCB.act != null)break;\n\n\t\t\t\t\t\tif(debug._dbg_withtrace)//DEBUG!!!\n\t\t\t\t\t\t\tdebug.__dbg_print( \"Error recovery: Discarding \\\"\" + labels[PCB.la] + \"\\\"\" );//DEBUG!!!\n\n\t\t\t\t\t\twhile(PCB.lex() != null)PCB.offset++;\n\n\t\t\t\t\t\tif(debug._dbg_withtrace)//DEBUG!!!\n\t\t\t\t\t\t\tdebug.__dbg_print( \"Error recovery: New token \\\"\" + labels[PCB.la] + \"\\\"\" );//DEBUG!!!\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(PCB.act === error || PCB.la === eof){\n\t\t\t\t\tif(debug._dbg_withtrace)//DEBUG!!!\n\t\t\t\t\t\tdebug.__dbg_print(\"\\tError recovery failed, terminating parse process...\");//DEBUG!!!\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(debug._dbg_withtrace)//DEBUG!!!\n\t\t\t\t\tdebug.__dbg_print(\"\\tError recovery succeeded, continuing\");//DEBUG!!!\n\t\t\t\t//Try to parse the next three tokens successfully...\n\t\t\t\tPCB.error_step = 3;\n\t\t\t}\n\t\t\tif(PCB.act > 0){//Shift\n\t\t\t\t//Parse tree generation\n\t\t\t\tif(debug._dbg_withparsetree){//DEBUG!!!\n\t\t\t\t\ttree.push(treenodes.length);//DEBUG!!!\n\t\t\t\t\ttreenodes.push({//DEBUG!!!\n\t\t\t\t\t\tsym:labels[ PCB.la ],//DEBUG!!!\n\t\t\t\t\t\tatt:PCB.att,//DEBUG!!!\n\t\t\t\t\t\tchild:[]//DEBUG!!!\n\t\t\t\t\t});//DEBUG!!!\n\t\t\t\t}//DEBUG!!!\n\t\t\t\n\t\t\t\tif(debug._dbg_withtrace)//DEBUG!!!\n\t\t\t\t\tdebug.__dbg_print(\"Shifting symbol: \" + labels[PCB.la] + \" (\" + PCB.att + \")\");//DEBUG!!!\n\t\t\t\tsstack.unshift(PCB.act);\n\t\t\t\tvstack.unshift(PCB.att);\n\t\t\t\tPCB.lex();\n\t\t\t\tif(debug._dbg_withtrace)//DEBUG!!!\n\t\t\t\t\tdebug.__dbg_print(\"\\tNew lookahead symbol: \" +\tlabels[PCB.la] + \" (\" + PCB.att + \")\");//DEBUG!!!\n\t\t\t\t//Successfull shift and right beyond error recovery?\n\t\t\t\tif(PCB.error_step > 0)PCB.error_step--;\n\t\t\t}else{\t//Reduce\t\n\t\t\t\tact = -PCB.act;\t\n\t\t\t\tif(debug._dbg_withtrace){//DEBUG!!!\n\t\t\t\t\tdebug.__dbg_print(\"Reducing by production: \" + act);//DEBUG!!!\n\t\t\t\t\tdebug.__dbg_print(\"\\tPerforming semantic action...\");//DEBUG!!!\n\t\t\t\t}//DEBUG!!!\n\t\t\t\trval = ACTIONS(act,vstack);\n\t\n\t\t\t\tif(debug._dbg_withparsetree)//DEBUG!!!\n\t\t\t\t\ttmptree = [];//DEBUG!!!\n\n\t\t\t\tif(debug._dbg_withtrace)//DEBUG!!!\n\t\t\t\t\tdebug.__dbg_print(\"\\tPopping \" + pop_tab[act][1] +  \" off the stack...\");//DEBUG!!!\n\t\t\t\t\n\t\t\t\tsstack.splice(0,pop_tab[act][1]);\n\t\t\t\tvstack.splice(0,pop_tab[act][1]);\n\t\t\t\tif(debug._dbg_withparsetree)//DEBUG!!!\n\t\t\t\t\ttmptree.push.apply(tmptree, tree.splice(tree.length - pop_tab[act][1], tree.length));//DEBUG!!!\n\t\t\t\t\n\t\t\t\tPCB.act = get_goto(sstack[0],pop_tab[act][0]);\n\t\t\t\t//Do some parse tree construction if desired\n\t\t\t\tif(debug._dbg_withparsetree){//DEBUG!!!\n\t\t\t\t\ttree.push(treenodes.length);//DEBUG!!!\n\t\t\t\t\ttreenodes.push({//DEBUG!!!\n\t\t\t\t\t\tsym:labels[pop_tab[act][0]],//DEBUG!!!\n\t\t\t\t\t\tatt:rval,//DEBUG!!!\n\t\t\t\t\t\tchild:tmptree.reverse()//DEBUG!!!\n\t\t\t\t\t\t});//DEBUG!!!\n\t\t\t\t}//DEBUG!!!\n\t\t\t\t//Goal symbol match?\n\t\t\t\tif(act === 0) break; //Don't use PCB.act here!\n\t\t\t\tif(debug._dbg_withtrace)//DEBUG!!!\n\t\t\t\t\tdebug.__dbg_print(\"\\tPushing non-terminal \" + labels[pop_tab[act][0]]);//DEBUG!!!\n\t\t\t\n\t\t\t\t//...and push it!\n\t\t\t\tsstack.unshift(PCB.act);\n\t\t\t\tvstack.unshift(rval);\n\t\t\t}\n\t\t}\n\t\tif(debug._dbg_withtrace){//DEBUG!!!\n\t\t\tdebug.__dbg_print(\"\\nParse complete.\");//DEBUG!!!\n\t\t\t//This function is used for parser drivers that will output//DEBUG!!!\n\t\t\t//the entire debug messages in a row.//DEBUG!!!\n\t\t\tdebug.__dbg_flush();//DEBUG!!!\n\t\t}//DEBUG!!!\n\n\t\tif(debug._dbg_withparsetree){//DEBUG!!!\n\t\t\tif(err_cnt === 0){//DEBUG!!!\n\t\t\t\tdebug.__dbg_print(\"\\n\\n--- Parse tree ---\");//DEBUG!!!\n\t\t\t\tdebug.__dbg_parsetree(0, treenodes, tree);//DEBUG!!!\n\t\t\t}else//DEBUG!!!\n\t\t\t\tdebug.__dbg_print(\"\\n\\nParse tree cannot be viewed. There where parse errors.\");//DEBUG!!!\n\t\t}//DEBUG!!!\n\t\treturn err_cnt;\n\t}\n\treturn parse;\n})(__##PREFIX##_debug,##EOF##,##WHITESPACE##,##ERROR_TOKEN##);\n\n##FOOTER##";
