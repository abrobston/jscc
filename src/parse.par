/~ -PARSER----------------------------------------------------------------------
JS/CC LALR(1) Parser Generator
Copyright (C) 2007-2012 by Phorward Software Technologies, Jan Max Meyer
http://jscc.phorward-software.com ++ contact<<AT>>phorward-software<<DOT>>com

File:	parse.par
Author:	Jan Max Meyer
Usage:	A parser for parsing JS/CC parser definitions; The first verions of
		JS/CC until v0.14 (had never been released!) worked with a hand-written
		recursive descent parser.

You may use, modify and distribute this software under the terms and conditions
of the BSD license. Please see LICENSE for more information.
----------------------------------------------------------------------------- ~/


[*
var		first_lhs;
var		cur_line;

//Wrapper for semantic errors
function line_error( line, txt ){
	_error( "line " + line + ": " + txt );
}
*]

/~
	Terminal symbol definitions
~/

	/~ Operators: ~/
	'##'
	'<'
	'>'
	'^'
	'!'
	';'
	':'
	'\|'
	'&'
	'~'
	'=>'

	/~ Lexeme: ~/
	'\[\*([^\*]\]|\*[^\]]|[^\*\]])*\*\]'	CODE			[*	return %match.substr(2, %match.length - 4 ); *]
	'\'([^\']|\\\')*\''						STRING_SINGLE
	'"([^"]|\\")*"'							STRING_DOUBLE
	'[A-Za-z0-9_-]+'						IDENT

	/~ Whitespace: ~/
	'\n' => Continue
	'/~([^~]/|~[^/]|[^~/])*~/' => Continue
	'[\t\r ]+' => Continue
	;

##


def: 			header_code token_assocs '##' grammar_defs footer_code
				;

/~ Token definition part ~/
header_code:	code_opt							[* code_head += %1; *]
				;

footer_code:	code_opt							[* code_foot += %1; *]
				;

token_assocs:	token_assocs token_assoc
				| token_assoc
				/~ | ~ ~/
				;

token_assoc:	'<' token_defs	';'					[*	assoc_level++;
														for( var i = 0; i < %2.length; i++ ){
															symbols[ %2[i] ].level = assoc_level;
															symbols[ %2[i] ].assoc = ASSOC_LEFT;
														}
													*]
				| '>' token_defs ';'				[*	assoc_level++;
														for( var i = 0; i < %2.length; i++ )
														{
															symbols[ %2[i] ].level = assoc_level;
															symbols[ %2[i] ].assoc = ASSOC_RIGHT;
														}
													*]
				| '^' token_defs ';'				[*	assoc_level++;
														for( var i = 0; i < %2.length; i++ ){
															symbols[ %2[i] ].level = assoc_level;
															symbols[ %2[i] ].assoc = ASSOC_NOASSOC;
														}
													*]
				| token_defs ';'
				| '!' string						[*	if( whitespace_token == -1 ){
															var regex = %2.substr( 1, %2.length - 2 );
															whitespace_token = create_symbol( "WHITESPACE", SYM_TERM, SPECIAL_WHITESPACE );
															compile_regex( regex, whitespace_token, %2[0] != '\''  );
														}
														else
															line_error( PCB.line, "Multiple whitespace definition" );
													*]
				;


token_defs:		token_defs token_def 				[*	%1.push(%2); return %1; *]
				| token_def							[*	return [%1]; *]
				;
token_def:		string identifier code_opt 			[*	%% = create_symbol( %2, SYM_TERM, SPECIAL_NO_SPECIAL );
														var regex = %1.substr( 1, %1.length - 2 );
														symbols[%%].code = %3;
														compile_regex( regex, symbols[ %% ].id, %1.charAt( 0 ) != '\''  );
													*]
				| string code_opt 					[*	var regex = %1.substr( 1, %1.length - 2 );
														%% = create_symbol( regex.replace( /\\/g, "" ), SYM_TERM, SPECIAL_NO_SPECIAL );
														symbols[%%].code = %2;

														compile_regex( regex, symbols[ %% ].id,  %1.charAt( 0 ) != '\'' );
													*]
				;


/~ Grammar definition part ~/

grammar_defs:	grammar_defs grammar_def
				| grammar_def
				;

grammar_def:	identifier ':' productions ';'		[*
														var nonterm = create_symbol( %1, SYM_NONTERM, SPECIAL_NO_SPECIAL );
														symbols[nonterm].defined = true;
														for( var i = 0; i < %3.length; i++ ){
															productions[ %3[i] ].lhs = nonterm;
															symbols[nonterm].prods.push( %3[i] );
														}

														if( first_lhs ){
															first_lhs = false;
															symbols[0].label = symbols[nonterm].label + "\'";
															productions[0].rhs.push( nonterm );
														}
													*]
				| ~ ';'
				;

productions:	productions '|' rhs					[*	%1.push(%3); return %1; *]
				| rhs								[*	return [%1]; *]
				;

rhs:			sequence_opt rhs_prec code_opt		[*
														var prod = new PROD({
															id:productions.length,
															rhs:%1,
															level:%2,
															code:(%3=="")?DEF_PROD_CODE:(%3)
														});
														//Get level of the leftmost terminal
														//as production level.
														if( prod.level == 0 )
														{
															if( prod.rhs.length > 0 )
																for( var i = prod.rhs.length-1; i >= 0; i-- )
																	if( symbols[prod.rhs[i]] &&
																		symbols[prod.rhs[i]].kind == SYM_TERM )
																	{
																		prod.level = symbols[prod.rhs[i]].level;
																		break;
																	}
														}

														productions.push( prod );
														return prod.id;
													*]
				;

rhs_prec:		'&' identifier						[* 	var index;
														if( ( index = find_symbol( %2, SYM_TERM, SPECIAL_NO_SPECIAL ) ) > -1 )
															return symbols[index].level;
														else
															line_error( PCB.line, "Call to undefined terminal \"" + %2 + "\"" );
													*]
				| '&' string						[*	var index;
														if( ( index = find_symbol( %2.substr( 1, %2.length - 2).replace( /\\/g, "" ),
																		SYM_TERM, SPECIAL_NO_SPECIAL ) ) > -1 )
															return symbols[index].level;
														else
															line_error(  PCB.line, "Call to undefined terminal \"" + %2 + "\"" );
													*]
				|									[*	Return(0); *]
				;

sequence_opt:	sequence
				|									[*	Return([]); *]
				;

sequence:		sequence symbol						[* %1.push(%2); return %1 *]
				| symbol							[* Return([%1]); *]
				;

symbol:			identifier							[*
														if( ( %% = find_symbol( %1, SYM_TERM, SPECIAL_NO_SPECIAL ) ) <= -1 )
															%% = create_symbol( %1, SYM_NONTERM, SPECIAL_NO_SPECIAL );
													*]
				| string							[*
														if( ( %% = find_symbol( %1.substr( 1, %1.length - 2).replace( /\\/g, "" ), SYM_TERM, SPECIAL_NO_SPECIAL ) ) <= -1 )
															line_error(  PCB.line, "Call to undefined terminal " + %1 );
													*]
				| '~'								[* return find_symbol( "ERROR_RESYNC", SYM_TERM,	SPECIAL_ERROR ); *]
				;

/~ Universal elements ~/
/~ TODO: apply this feature by another way ~/
code_opt:
	code
	|'=>' identifier [* return "return "+ %2 + ".apply(null, arguments);" *]
	| [* return ""; *]
;

code:			code CODE							[* return %1 + %2; *]
				| CODE
				;

string:			STRING_SINGLE
				| STRING_DOUBLE
				;

identifier:		IDENT
				;

[*
function parse_grammar( str, filename ){
	var error_offsets = [];
	var error_expects = [];
	var parse_error = 0;

	first_lhs = true;
	cur_line = 1;

	//##PREFIX##_dbg_withstepbystep = true;
	//##PREFIX##_dbg_withtrace = true;

	if( ( parse_error += __jsccparse( str, error_offsets, error_expects ) ) > 0 )
	{
		for( i = 0; i < parse_error; i++ )
			line_error( ( str.substr( 0, error_offsets[i] ).match( /\n/g ) ?
				str.substr( 0, error_offsets[i] ).match( /\n/g ).length : 1 ),
					"Parse error near\n\t"  + str.substr( error_offsets[i], 30 ) +
						( ( error_offsets[i] + 30 < str.substr( error_offsets[i] ).length ) ?
							"..." : "" ) + "\n\t" + error_expects[i].join() + " expected" );
	}
	return parse_error;
}
*]
