/~ -PARSER----------------------------------------------------------------------
JS/CC LALR(1) Parser Generator
Copyright (C) 2007-2012 by Phorward Software Technologies, Jan Max Meyer
http://jscc.phorward-software.com ++ contact<<AT>>phorward-software<<DOT>>com

File:	regex.par
Author:	Jan Max Meyer
Usage:	A parser for regular expressions, with NFA construction using the
		Thompson algorithm. This JS/CC parser module for regular expressions
		has been implemented using a very early version of JS/CC itself,
		which generated a pseudo-lexer using the JavaScript build-in RegExp-
		object.

You may use, modify and distribute this software under the terms and conditions
of the BSD license. Please see LICENSE for more information.
----------------------------------------------------------------------------- ~/

[*
var first_nfa;
var last_nfa;
var created_nfas; //Must always be initialized by compile_regex()...

function create_nfa( where )
{
	var pos;
	var nfa;
	var i;

	/*
		Use an empty item if available,
		else create a new one...
	*/
	for( i = 0; i < where.length; i++ )
		if( where[i].edge == EDGE_FREE )
			break;

	if( i == where.length ){
		nfa = new NFA()
		where.push( nfa );
	}else
		nfa = where[i];

	nfa.edge = EDGE_EPSILON;
	nfa.ccl=new BitSet(MAX_CHAR);
	nfa.accept = -1;
	nfa.follow = -1;
	nfa.follow2 = -1;
	nfa.weight = -1;

	created_nfas.push( i );

	return i;
}

*]


	'\|'
	'\*'
	'\+'
	'\?'
	'\('
	'\)'
	'\['
	'\]'
	'\.'		ANY_CHAR
	'\\[0-9]+'	ASCII_CODE
	'\\.'		ESCAPED_CHAR
	'.'			ANY
	;


##


RegEx:			Expression						[*	%% = new PARAM();
													NFA_states.value[ first_nfa ].follow = %1.start;
													last_nfa = %1.end;
												*]
				;

Expression:		Expression '|' Catenation		[*
													%% = new PARAM({
														start:NFA_states.create(),
														end:NFA_states.create()
														});
													NFA_states.value[%%.start].follow = %1.start;
													NFA_states.value[%%.start].follow2 = %3.start;

													NFA_states.value[%1.end].follow = %%.end;
													NFA_states.value[%3.end].follow = %%.end;
												*]
				| Catenation
				;

Catenation:		Catenation Factor				[*
													var weight=NFA_states.value[%1.end].weight;///SV: if weight unused - delete this
													NFA_states.value[%1.end]=new NFA(NFA_states.value[%2.start]);
													NFA_states.value[%1.end].weight=weight;///SV: if weight unused - delete this
													NFA_states.value[%2.start].edge = EDGE_FREE;

													%1.end = %2.end;

													return %1;
												*]
				| Factor
				;

Factor:			Term '*'						[*
													%% = new PARAM({
														start:NFA_states.create(),
														end:NFA_states.create()
													});
													NFA_states.value[%%.start].follow = %1.start;
													NFA_states.value[%1.end].follow = %%.end;

													NFA_states.value[%%.start].follow2 = %%.end;
													NFA_states.value[%1.end].follow2 = %1.start;
												*]
				| Term '+'						[*
													%% = new PARAM({
														start:NFA_states.create(),
														end:NFA_states.create()
													});
													NFA_states.value[%%.start].follow = %1.start;
													NFA_states.value[%1.end].follow = %%.end;

													NFA_states.value[%1.end].follow2 = %1.start;
												*]
				| Term '?'						[*
													%% = new PARAM({
														start:NFA_states.create(),
														end:NFA_states.create()
														});
													NFA_states.value[%%.start].follow = %1.start;
													NFA_states.value[%%.start].follow2 = %%.end;
													NFA_states.value[%1.end].follow = %%.end;
												*]
				| Term
				;

Term:			Character						[*	%% = new PARAM();
													%%.start = NFA_states.create();
													%%.end = NFA_states.value[%%.start].follow
														= NFA_states.create();
													NFA_states.value[%%.start].edge = EDGE_CHAR;

													NFA_states.value[%%.start].ccl.set(%1.charCodeAt( 0 ), true );
												*]
				| CharacterSet
				| '(' Expression ')'			[*	return %2; *]
				;

CharacterSet:	'[' CharClass ']'				[*	var negate = false;
													var i = 0, j, start;
													%% = new PARAM();
													%%.start = NFA_states.create();
													%%.end = NFA_states.value[%%.start].follow
														= NFA_states.create();
													NFA_states.value[%%.start].edge = EDGE_CHAR;

													if( %2.charAt( i ) == '^' ){
														negate = true;
														for( var j = MIN_CHAR; j < MAX_CHAR; j++ )
															NFA_states.value[%%.start].ccl.set(j,true);
														i++;
													}
													for( ; i < %2.length; i++ ){
														if( %2.charAt( i+1 ) == '-'	&& i+2 < %2.length ){
															i++;
															for( j = %2.charCodeAt( i-1 );
																	j < %2.charCodeAt( i+1 );
																		j++ )
																NFA_states.value[%%.start].ccl.set(j, !negate);
														}
														else
															NFA_states.value[%%.start].ccl.set(%2.charCodeAt(i), !negate);
													}
												*]
				| ANY_CHAR						[*	%% = new PARAM();

													%%.start = NFA_states.create();
													%%.end = NFA_states.value[%%.start].follow
														= NFA_states.create();
													NFA_states.value[%%.start].edge = EDGE_CHAR;
													for( var i = MIN_CHAR; i < MAX_CHAR; i++ )
														NFA_states.value[%%.start].ccl.set(i, true);
												*]
				;

CharClass:		CharClass Character				[*	return %1 + %2; *]
				|								[*	return ""; *]
				;


Character:		ASCII_CODE						[*	return String.fromCharCode( %1.substr( 1 ) ); *]
				| ESCAPED_CHAR					[*	return {n:'\n',r:'\r',t:'\t',a:'\a'}[%1.substr(1)]||%1.substr(1); *]
				| ANY							[*	return %1; *]
				;

[*

function compile_regex( str, accept, case_insensitive ){
	var i, j;
	var weight = 0;
	var true_edges = 0;
	var error_offsets = [];
	var error_expects = [];
	var error_count = 0;

	if( str == "" )
		return;

	//_print( "str = >" + str + "< " + case_insensitive );

	created_nfas = [];

	first_nfa = NFA_states.create();
	if( ( error_count = __##PREFIX##parse( str, error_offsets, error_expects ) ) == 0 ){
		//If the symbol should be case-insensitive, manipulate the
		//character sets on the newly created items.
		if( case_insensitive ){
			for( i = 0; i < created_nfas.length; i++ ){
				if( NFA_states.value[ created_nfas[i] ].edge == EDGE_CHAR ){
					for( j = MIN_CHAR; j < MAX_CHAR; j++ ){
						if( NFA_states.value[ created_nfas[i] ].ccl.get( j ) ){
							NFA_states.value[ created_nfas[i] ].ccl.set(String.fromCharCode( j ).toUpperCase().charCodeAt( 0 ), true );
							NFA_states.value[ created_nfas[i] ].ccl.set(String.fromCharCode( j ).toLowerCase().charCodeAt( 0 ), true );
						}
					}
				}
			}
		}

		/*
			2008-5-9	Radim Cebis:

			I think that computing weight of the NFA_states.value is weird,
			IMHO nfa_state which accepts a symbol, should have
			weight according to the order...
		*/
		NFA_states.value[ last_nfa ].accept = accept;
		NFA_states.value[ last_nfa ].weight = regex_weight++;

		if( first_nfa > 0 ){
			i = 0;
			while( NFA_states.value[i].follow2 != -1 )
				i = NFA_states.value[i].follow2;

			NFA_states.value[i].follow2 = first_nfa;
		}
	}else{
		for( i = 0; i < error_count; i++ ){
			var spaces = '';
			for( j = 0; j < error_offsets[i]; j++ )
				spaces += " ";

			line_error( cur_line, "Regular expression:\n\t" + str + "\n\t" +
			 		spaces + "^ expecting " + error_expects[i].join() );
		}
	}
}


//TESTING AREA ;)
//compile_regex( "[A-Z][A-Z0-9]*", 0 );
//compile_regex( "ab|c", 1 );
//compile_regex( "[0-9]+", 1 );
//print_nfa();
//var d = create_subset( NFA_states.value );
//print_dfa( d );
//d = minimize_dfa( d );
//print_dfa( d );

*]

